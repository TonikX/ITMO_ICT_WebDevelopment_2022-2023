{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022 \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u21161 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0417\u0430\u0439\u0446\u0435\u0432\u0430 \u0410\u043d\u0430\u0441\u0442\u0430\u0441\u0438\u044f K33402","title":"\u0417\u0430\u0433\u043b\u0430\u0432\u043d\u0430\u044f"},{"location":"#web-2022","text":"","title":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022"},{"location":"#no1-web-","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u21161 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435"},{"location":"#k33402","text":"","title":"\u0417\u0430\u0439\u0446\u0435\u0432\u0430 \u0410\u043d\u0430\u0441\u0442\u0430\u0441\u0438\u044f K33402"},{"location":"lab1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u0447\u0430 \u21161 server.py import socket HELLO_MESSAGE = 'Hello, client' LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) sock . bind (( '' , LOCAL_PORT )) while True : data , address = sock . recvfrom ( BUFFER_SIZE ) print ( data . decode ( \"utf-8\" )) sock . sendto ( HELLO_MESSAGE . encode ( \"utf-8\" ), address ) client.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 8080 )) s . sendall ( 'Hello, server.' . encode ( 'utf-8' )) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0444\u0440\u0430\u0437\u0443. data = s . recv ( 1024 ) #\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0438\u0437 \u0441\u043e\u043a\u0435\u0442\u0430. print ( data . decode ( 'utf-8' )) s . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21162 server.py from math import sqrt s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind (( 'localhost' , 3030 )) s . listen ( 1 ) conn , addr = s . accept () while True : data = conn . recv ( 1024 ) if not data : break list_of_coef = data . decode ( 'utf-8' ) . split ( ',' ) for i in range ( len ( list_of_coef )): list_of_coef [ i ] = int ( list_of_coef [ i ]) #\u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u044b d = list_of_coef [ 1 ] ** 2 - 4 * list_of_coef [ 0 ] * list_of_coef [ 2 ] if d < 0 : conn . sendall ( '\u041d\u0435\u0442 \u0440\u0435\u0448\u0435\u043d\u0438\u0439' . encode ( 'utf-8' )) elif d == 0 : result = '\u041a\u043e\u0440\u0435\u043d\u044c \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: ' + str ( round ( - list_of_coef [ 1 ] / ( 2 * list_of_coef [ 0 ]), 3 )) conn . sendall ( result . encode ( 'utf-8' )) else : result = '\u041a\u043e\u0440\u043d\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: ' + str ( round (( - list_of_coef [ 1 ] - sqrt ( d )) / ( 2 * list_of_coef [ 0 ]), 3 )) + ' ' + str ( round (( - list_of_coef [ 1 ] + sqrt ( d )) / ( 2 * list_of_coef [ 0 ]), 3 )) conn . sendall ( result . encode ( 'utf-8' )) conn . close () client.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 3030 )) print ( '\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f' ) a , b , c = map ( int , input () . split ()) s . sendall (( str ( a ) + ',' + str ( b ) + ',' + str ( c )) . encode ( 'utf-8' )) answer = s . recv ( 1024 ) print ( answer . decode ( 'utf-8' )) s . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21163 server.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind (( 'localhost' , 555 )) s . listen ( 1 ) while True : conn , addr = s . accept () #\u0440\u0430\u0431\u043e\u0442\u0430 \u0441 \u0444\u0430\u0439\u043b\u043e\u043c html_page = open ( 'index.html' ) html_content = html_page . read () html_page . close () html_response = 'HTTP/1.0 200 OK \\n ' + html_content conn . sendall ( html_response . encode ( 'utf-8' )) conn . close () client.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 555 )) data = s . recv ( 1024 ) #\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0438\u0437 \u0441\u043e\u043a\u0435\u0442\u0430. print ( data . decode ( 'utf-8' )) s . close () index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Test page </ title > </ head > < body > < p > \"Hello, world!\" </ p > </ body > </ html > \u0417\u0430\u0434\u0430\u0447\u0430 \u21164 server.py import threading , socket def send_to_chat ( sender , msg ): for client in clients : if sender != client : client . sendall ( msg ) def handle_client ( cl_sock , cl_addr ): #\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 print ( f 'Client { cl_addr [ 0 ] } : { cl_addr [ 1 ] } join the chat' ) while True : try : message = cl_sock . recv ( 1024 ) #\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 if message . decode ( 'utf-8' ) . find ( 'bye' ) != - 1 : #\u043a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u043a\u0438\u0434\u0430\u0435\u0442 send_to_chat ( cl_sock , message ) break elif message . decode ( 'utf-8' ) . find ( 'Error' ) != - 1 : break send_to_chat ( cl_sock , message ) #\u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\u043c \u0447\u0430\u0442\u0430 except socket . error : print ( f 'Client { cl_addr [ 0 ] } : { cl_addr [ 1 ] } suddenly left' ) break print ( f 'Client { cl_addr [ 0 ] } : { cl_addr [ 1 ] } left the chat' ) clients . remove ( cl_sock ) cl_sock . close () #\u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u0441\u0435\u0440\u0432\u0435\u0440 s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) host = 'localhost' port = 9090 s . bind (( host , port )) s . listen ( 100 ) clients = [] print ( 'Starting chat server' ) while True : try : client_socket , client_address = s . accept () if client_address not in clients : clients . append ( client_socket ) t1 = threading . Thread ( target = handle_client , args = ( client_socket , client_address )) t1 . start () except KeyboardInterrupt : print ( 'Server stopped' ) break s . close () client.py import socket , threading , time shutdown = False def recive (): while not shutdown : try : data = s . recv ( 1024 ) . decode ( 'utf-8' ) print ( data ) except socket . error : time . sleep ( 0.5 ) continue s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) host = 'localhost' port = 9090 s . connect (( host , port )) s . setblocking ( 0 ) alias = input ( \"Name: \" ) print ( 'If you want to leave the chat write: bye' ) rt = threading . Thread ( target = recive ) rt . start () while True : try : message = input () s . sendall (( f ' { alias } :: { message } ' ) . encode ( 'utf-8' )) if message == 'bye' : print ( 'You left the chat' ) shutdown = True break except : s . sendall ( 'Error' . encode ( 'utf-8' )) print ( 'Error. Disconected' ) shutdown = True break s . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21165 http_server_task_5.py import socket class Response : def __init__ ( self , status , reason , headers = None , body = None ): self . status = status self . reason = reason self . headers = headers self . body = body class MyHTTPServer : def __init__ ( self , host , port ): self . host = host self . port = port self . marks = {} def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM , proto = 0 ) try : serv_sock . bind (( self . host , self . port )) serv_sock . listen () while True : client , address = serv_sock . accept () self . serve_client ( client ) except KeyboardInterrupt : serv_sock . close () def serve_client ( self , client ): try : data = client . recv ( 1024 ) . decode ( 'utf-8' ) req = self . parse_request ( data ) res = self . handle_request ( req ) self . send_response ( client , res ) except Exception as e : print ( e ) client . close () def parse_request ( self , data ): req = data . rstrip ( ' \\r\\n ' ) words = req [: data . index ( \" \\n \" )] . split () if len ( words ) != 3 : raise Exception ( 'Malformed request line' ) method , target , ver = words if ver != 'HTTP/1.1' : raise Exception ( 'Unexpected HTTP version' ) request = { 'data' : {}, 'method' : method } if '?' in target : request [ 'method' ] = 'POST' values = target . split ( '?' )[ 1 ] . split ( '&' ) for value in values : a , b = value . split ( '=' ) request [ 'data' ][ a ] = b return request def handle_request ( self , req ): if req [ 'method' ] == 'POST' : return self . handle_post ( req ) else : return self . handle_get () def handle_get ( self ): content_type = 'text/html; charset=utf-8' body = '<html><head><style></style></head><body>' body += '<form><label>\u0414\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430</label><input name=\"discipline\" /><br><label>\u041e\u0446\u0435\u043d\u043a\u0430</label><input name=\"grade\"/><input type=\"submit\"></form>' for subject in self . marks : body += f '<div><span> { subject } : { self . marks [ subject ] } </span></div>' body += '</div></body></html>' body = body . encode ( 'utf-8' ) headers = [( 'Content-Type' , content_type ), ( 'Content-Length' , len ( body ))] return Response ( 200 , 'OK' , headers , body ) def handle_post ( self , request ): discipline = request [ 'data' ][ 'discipline' ] grade = request [ 'data' ][ 'grade' ] if discipline not in self . marks : self . marks [ discipline ] = [] self . marks [ discipline ] . append ( grade ) return self . handle_get () def send_response ( self , conn , resp ): rfile = conn . makefile ( 'wb' ) status_line = f 'HTTP/1.1 { resp . status } { resp . reason } \\r\\n ' rfile . write ( status_line . encode ( 'utf-8' )) if resp . headers : for ( key , value ) in resp . headers : header_line = f ' { key } : { value } \\r\\n ' rfile . write ( header_line . encode ( 'utf-8' )) rfile . write ( b ' \\r\\n ' ) if resp . body : rfile . write ( resp . body ) rfile . flush () rfile . close () # 6. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u043e\u0442\u0432\u0435\u0442\u0430. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 status line \u0432\u0438\u0434\u0430 HTTP/1.1 <status_code> <reason>. \u0417\u0430\u0442\u0435\u043c, \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0438 \u0438 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443, \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0449\u0443\u044e \u043a\u043e\u043d\u0435\u0446 \u0441\u0435\u043a\u0446\u0438\u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u0432. if __name__ == '__main__' : host = '127.0.0.1' port = 8000 serv = MyHTTPServer ( host , port ) try : serv . serve_forever () except KeyboardInterrupt : pass","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lab1/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lab1/#no1_1","text":"server.py import socket HELLO_MESSAGE = 'Hello, client' LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) sock . bind (( '' , LOCAL_PORT )) while True : data , address = sock . recvfrom ( BUFFER_SIZE ) print ( data . decode ( \"utf-8\" )) sock . sendto ( HELLO_MESSAGE . encode ( \"utf-8\" ), address ) client.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 8080 )) s . sendall ( 'Hello, server.' . encode ( 'utf-8' )) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0444\u0440\u0430\u0437\u0443. data = s . recv ( 1024 ) #\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0438\u0437 \u0441\u043e\u043a\u0435\u0442\u0430. print ( data . decode ( 'utf-8' )) s . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21161"},{"location":"lab1/#no2","text":"server.py from math import sqrt s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind (( 'localhost' , 3030 )) s . listen ( 1 ) conn , addr = s . accept () while True : data = conn . recv ( 1024 ) if not data : break list_of_coef = data . decode ( 'utf-8' ) . split ( ',' ) for i in range ( len ( list_of_coef )): list_of_coef [ i ] = int ( list_of_coef [ i ]) #\u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u044b d = list_of_coef [ 1 ] ** 2 - 4 * list_of_coef [ 0 ] * list_of_coef [ 2 ] if d < 0 : conn . sendall ( '\u041d\u0435\u0442 \u0440\u0435\u0448\u0435\u043d\u0438\u0439' . encode ( 'utf-8' )) elif d == 0 : result = '\u041a\u043e\u0440\u0435\u043d\u044c \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: ' + str ( round ( - list_of_coef [ 1 ] / ( 2 * list_of_coef [ 0 ]), 3 )) conn . sendall ( result . encode ( 'utf-8' )) else : result = '\u041a\u043e\u0440\u043d\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: ' + str ( round (( - list_of_coef [ 1 ] - sqrt ( d )) / ( 2 * list_of_coef [ 0 ]), 3 )) + ' ' + str ( round (( - list_of_coef [ 1 ] + sqrt ( d )) / ( 2 * list_of_coef [ 0 ]), 3 )) conn . sendall ( result . encode ( 'utf-8' )) conn . close () client.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 3030 )) print ( '\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f' ) a , b , c = map ( int , input () . split ()) s . sendall (( str ( a ) + ',' + str ( b ) + ',' + str ( c )) . encode ( 'utf-8' )) answer = s . recv ( 1024 ) print ( answer . decode ( 'utf-8' )) s . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21162"},{"location":"lab1/#no3","text":"server.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind (( 'localhost' , 555 )) s . listen ( 1 ) while True : conn , addr = s . accept () #\u0440\u0430\u0431\u043e\u0442\u0430 \u0441 \u0444\u0430\u0439\u043b\u043e\u043c html_page = open ( 'index.html' ) html_content = html_page . read () html_page . close () html_response = 'HTTP/1.0 200 OK \\n ' + html_content conn . sendall ( html_response . encode ( 'utf-8' )) conn . close () client.py import socket s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 555 )) data = s . recv ( 1024 ) #\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0438\u0437 \u0441\u043e\u043a\u0435\u0442\u0430. print ( data . decode ( 'utf-8' )) s . close () index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Test page </ title > </ head > < body > < p > \"Hello, world!\" </ p > </ body > </ html >","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163"},{"location":"lab1/#no4","text":"server.py import threading , socket def send_to_chat ( sender , msg ): for client in clients : if sender != client : client . sendall ( msg ) def handle_client ( cl_sock , cl_addr ): #\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 print ( f 'Client { cl_addr [ 0 ] } : { cl_addr [ 1 ] } join the chat' ) while True : try : message = cl_sock . recv ( 1024 ) #\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 if message . decode ( 'utf-8' ) . find ( 'bye' ) != - 1 : #\u043a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u043a\u0438\u0434\u0430\u0435\u0442 send_to_chat ( cl_sock , message ) break elif message . decode ( 'utf-8' ) . find ( 'Error' ) != - 1 : break send_to_chat ( cl_sock , message ) #\u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\u043c \u0447\u0430\u0442\u0430 except socket . error : print ( f 'Client { cl_addr [ 0 ] } : { cl_addr [ 1 ] } suddenly left' ) break print ( f 'Client { cl_addr [ 0 ] } : { cl_addr [ 1 ] } left the chat' ) clients . remove ( cl_sock ) cl_sock . close () #\u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u0441\u0435\u0440\u0432\u0435\u0440 s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) host = 'localhost' port = 9090 s . bind (( host , port )) s . listen ( 100 ) clients = [] print ( 'Starting chat server' ) while True : try : client_socket , client_address = s . accept () if client_address not in clients : clients . append ( client_socket ) t1 = threading . Thread ( target = handle_client , args = ( client_socket , client_address )) t1 . start () except KeyboardInterrupt : print ( 'Server stopped' ) break s . close () client.py import socket , threading , time shutdown = False def recive (): while not shutdown : try : data = s . recv ( 1024 ) . decode ( 'utf-8' ) print ( data ) except socket . error : time . sleep ( 0.5 ) continue s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) host = 'localhost' port = 9090 s . connect (( host , port )) s . setblocking ( 0 ) alias = input ( \"Name: \" ) print ( 'If you want to leave the chat write: bye' ) rt = threading . Thread ( target = recive ) rt . start () while True : try : message = input () s . sendall (( f ' { alias } :: { message } ' ) . encode ( 'utf-8' )) if message == 'bye' : print ( 'You left the chat' ) shutdown = True break except : s . sendall ( 'Error' . encode ( 'utf-8' )) print ( 'Error. Disconected' ) shutdown = True break s . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21164"},{"location":"lab1/#no5","text":"http_server_task_5.py import socket class Response : def __init__ ( self , status , reason , headers = None , body = None ): self . status = status self . reason = reason self . headers = headers self . body = body class MyHTTPServer : def __init__ ( self , host , port ): self . host = host self . port = port self . marks = {} def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM , proto = 0 ) try : serv_sock . bind (( self . host , self . port )) serv_sock . listen () while True : client , address = serv_sock . accept () self . serve_client ( client ) except KeyboardInterrupt : serv_sock . close () def serve_client ( self , client ): try : data = client . recv ( 1024 ) . decode ( 'utf-8' ) req = self . parse_request ( data ) res = self . handle_request ( req ) self . send_response ( client , res ) except Exception as e : print ( e ) client . close () def parse_request ( self , data ): req = data . rstrip ( ' \\r\\n ' ) words = req [: data . index ( \" \\n \" )] . split () if len ( words ) != 3 : raise Exception ( 'Malformed request line' ) method , target , ver = words if ver != 'HTTP/1.1' : raise Exception ( 'Unexpected HTTP version' ) request = { 'data' : {}, 'method' : method } if '?' in target : request [ 'method' ] = 'POST' values = target . split ( '?' )[ 1 ] . split ( '&' ) for value in values : a , b = value . split ( '=' ) request [ 'data' ][ a ] = b return request def handle_request ( self , req ): if req [ 'method' ] == 'POST' : return self . handle_post ( req ) else : return self . handle_get () def handle_get ( self ): content_type = 'text/html; charset=utf-8' body = '<html><head><style></style></head><body>' body += '<form><label>\u0414\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430</label><input name=\"discipline\" /><br><label>\u041e\u0446\u0435\u043d\u043a\u0430</label><input name=\"grade\"/><input type=\"submit\"></form>' for subject in self . marks : body += f '<div><span> { subject } : { self . marks [ subject ] } </span></div>' body += '</div></body></html>' body = body . encode ( 'utf-8' ) headers = [( 'Content-Type' , content_type ), ( 'Content-Length' , len ( body ))] return Response ( 200 , 'OK' , headers , body ) def handle_post ( self , request ): discipline = request [ 'data' ][ 'discipline' ] grade = request [ 'data' ][ 'grade' ] if discipline not in self . marks : self . marks [ discipline ] = [] self . marks [ discipline ] . append ( grade ) return self . handle_get () def send_response ( self , conn , resp ): rfile = conn . makefile ( 'wb' ) status_line = f 'HTTP/1.1 { resp . status } { resp . reason } \\r\\n ' rfile . write ( status_line . encode ( 'utf-8' )) if resp . headers : for ( key , value ) in resp . headers : header_line = f ' { key } : { value } \\r\\n ' rfile . write ( header_line . encode ( 'utf-8' )) rfile . write ( b ' \\r\\n ' ) if resp . body : rfile . write ( resp . body ) rfile . flush () rfile . close () # 6. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u043e\u0442\u0432\u0435\u0442\u0430. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 status line \u0432\u0438\u0434\u0430 HTTP/1.1 <status_code> <reason>. \u0417\u0430\u0442\u0435\u043c, \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0438 \u0438 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443, \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0449\u0443\u044e \u043a\u043e\u043d\u0435\u0446 \u0441\u0435\u043a\u0446\u0438\u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u0432. if __name__ == '__main__' : host = '127.0.0.1' port = 8000 serv = MyHTTPServer ( host , port ) try : serv . serve_forever () except KeyboardInterrupt : pass","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21165"}]}