{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022 \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u21161 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0417\u0430\u0439\u0446\u0435\u0432\u0430 \u0410\u043d\u0430\u0441\u0442\u0430\u0441\u0438\u044f K33402","title":"\u0417\u0430\u0433\u043b\u0430\u0432\u043d\u0430\u044f"},{"location":"#web-2022","text":"","title":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022"},{"location":"#no1-web-","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u21161 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435"},{"location":"#k33402","text":"","title":"\u0417\u0430\u0439\u0446\u0435\u0432\u0430 \u0410\u043d\u0430\u0441\u0442\u0430\u0441\u0438\u044f K33402"},{"location":"lab1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u0447\u0430 \u21161 server.py import socket HELLO_MESSAGE = 'Hello, client' LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 UDP \u0441\u043e\u043a\u0435\u0442\u0430 sock . bind (( '' , LOCAL_PORT )) # \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0430 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u043f\u043e\u0440\u0442\u0443 while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 data , address = sock . recvfrom ( BUFFER_SIZE ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0430\u0434\u0440\u0435\u0441 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 print ( data . decode ( \"utf-8\" )) # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 sock . sendto ( HELLO_MESSAGE . encode ( \"utf-8\" ), address ) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0442\u0432\u0435\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 client.py import socket HELLO_MESSAGE = 'Hello, server' LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 UDP \u0441\u043e\u043a\u0435\u0442\u0430 sock . sendto ( HELLO_MESSAGE . encode ( \"utf-8\" ), ( \"localhost\" , LOCAL_PORT )) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 data = sock . recv ( BUFFER_SIZE ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 print ( data . decode ( \"utf-8\" )) # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043e\u0442\u0432\u0435\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0417\u0430\u0434\u0430\u0447\u0430 \u21162 server.py import socket from math import sqrt LOCAL_PORT = 25030 MAX_CLIENTS = 1 BUFFER_SIZE = 1024 sock = socket . socket () # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 TCP \u0441\u043e\u043a\u0435\u0442\u0430 sock . bind (( '' , LOCAL_PORT )) # \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0430 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u043f\u043e\u0440\u0442\u0443 sock . listen ( MAX_CLIENTS ) # \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u0445 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 conn , addr = sock . accept () # \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 1 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 print ( '\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e.' ) step = 1 with_hypo_input = False side_a = 0 side_b = 0 def solve_pyth ( a , b , with_hypo ): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u043f\u043e \u0442\u0435\u043e\u0440\u0435\u043c\u0435 \u041f\u0438\u0444\u0430\u0433\u043e\u0440\u0430 high = a if a > b else b low = a if a < b else b return sqrt ( high * high + low * low * ( - 1 if with_hypo else 1 )) while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 data = conn . recv ( 1024 ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 if not data : break message = data . decode ( 'utf-8' ) if message == '\u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044c' : # \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u043e \u043a\u043e\u043c\u0430\u043d\u0434\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 break if step == 1 : # \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0448\u0430\u0433\u0430 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u0430, \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0434\u0430\u043d\u043d\u044b\u0435 conn . send ( '\u0412\u044b \u0441\u043e\u0431\u0438\u0440\u0430\u0435\u0442\u0435\u0441\u044c \u0432\u0432\u043e\u0434\u0438\u0442\u044c \u0433\u0438\u043f\u043e\u0442\u0435\u043d\u0443\u0437\u0443? (\u0434\u0430/\u043d\u0435\u0442)' . encode ( 'utf-8' )) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0432\u043e\u043f\u0440\u043e\u0441 \u043f\u0440\u043e \u0433\u0438\u043f\u043e\u0442\u0435\u043d\u0443\u0437\u0443.' ) step += 1 elif step == 2 : if message . lower () == '\u0434\u0430' : with_hypo_input = True print ( '\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0442\u0432\u0435\u0442: ' + message ) conn . send ( '\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0435\u0440\u0432\u0443\u044e \u0441\u0442\u043e\u0440\u043e\u043d\u0443.' . encode ( 'utf-8' )) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0437\u0430\u043f\u0440\u043e\u0441 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b.' ) step += 1 elif step == 3 : side_a = float ( message ) print ( '\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0442\u0432\u0435\u0442: ' + message ) conn . send ( '\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0442\u043e\u0440\u0443\u044e \u0441\u0442\u043e\u0440\u043e\u043d\u0443.' . encode ( 'utf-8' )) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0437\u0430\u043f\u0440\u043e\u0441 \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b.' ) step += 1 elif step == 4 : print ( '\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0442\u0432\u0435\u0442: ' + message ) side_b = float ( message ) side_c = solve_pyth ( side_a , side_b , with_hypo_input ) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0440\u0435\u0448\u0435\u043d\u0438\u0435: ' + str ( side_c )) conn . send (( '\u0422\u0440\u0435\u0442\u044c\u044f \u0441\u0442\u043e\u0440\u043e\u043d\u0430: ' + str ( side_c )) . encode ( 'utf-8' )) step = 1 conn . close () client.py import socket LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket () # \u0441\u043e\u0437\u0434\u0430\u0435\u043c TCP \u0441\u043e\u043a\u0435\u0442 sock . connect (( 'localhost' , LOCAL_PORT )) # \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u0441\u044f \u043a \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 message = input () # \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0432\u0432\u043e\u0434 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f if message . lower () == 'exit' : # \u0435\u0441\u043b\u0438 \u0432\u0432\u0435\u0434\u0435\u043d\u043e \"exit\", \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 break sock . send ( message . encode ( 'utf-8' )) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 data = sock . recv ( BUFFER_SIZE ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 print ( data . decode ( 'utf-8' )) # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043e\u0442\u0432\u0435\u0442 sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21163 server.py import socket from wsgiref.handlers import format_date_time from datetime import datetime from time import mktime LOCAL_PORT = 25030 MAX_CLIENTS = 10 BUFFER_SIZE = 1024 SERVER_NAME = 'chiclasserver/1.0.0' sock = socket . socket () sock . bind (( '' , LOCAL_PORT )) sock . listen ( MAX_CLIENTS ) with open ( 'index.html' , 'r' ) as file : # \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 file_data = file . read () now = datetime . now () # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u0432 \u043d\u0443\u0436\u043d\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0434\u043b\u044f \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0432 \u043f\u043e\u043b\u0435 \u0434\u0430\u0442\u044b stamp = mktime ( now . timetuple ()) date = format_date_time ( stamp ) dt = datetime . strptime ( '24/09/22 15:08' , ' %d /%m/%y %H:%M' ) # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u0432 \u043d\u0443\u0436\u043d\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0434\u043b\u044f \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0432 \u043f\u043e\u043b\u0435 # \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 stamp = mktime ( dt . timetuple ()) last_modified = format_date_time ( stamp ) content_length = len ( file_data . encode ( 'utf-8' )) # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430 data = f '''HTTP/1.1 200 OK Server: { SERVER_NAME } Date: { date } Content-Type: text/html Content-Length: { content_length } Last-Modified: { last_modified } Connection: keep-alive Access-Control-Allow-Origin: * Accept-Ranges: bytes ''' data += file_data while True : conn , addr = sock . accept () conn . send ( data . encode ( 'utf-8' )) print ( 'index.html \u0431\u044b\u043b \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d' ) conn . close () client.py import socket LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket () sock . connect (( 'localhost' , LOCAL_PORT )) data = sock . recv ( BUFFER_SIZE ) print ( data . decode ( 'utf-8' )) sock . close () index.html <!DOCTYPE html> < html > < head > < title > Web programming lab 1 </ title > </ head > < body > < h1 > Hello world </ h1 > </ body > </ html > \u0417\u0430\u0434\u0430\u0447\u0430 \u21164 server.py import socket from _thread import * LOCAL_PORT = 25030 MAX_CLIENTS = 10 BUFFER_SIZE = 1024 sock = socket . socket () sock . bind (( '' , LOCAL_PORT )) sock . listen ( MAX_CLIENTS ) list_of_users = [] # \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 def client_thread ( user ): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f connection = user [ 0 ] connection . send ( '\u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u0447\u0430\u0442!' . encode ( 'utf-8' )) while True : try : name = user [ 1 ] data = connection . recv ( 1024 ) if data : message = data . decode ( 'utf-8' ) if name == '' : # \u0435\u0441\u043b\u0438 \u0438\u043c\u044f \u043d\u0435 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u043e, \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u043c\u0432\u0430\u0435\u043c user [ 1 ] = message print ( '\u041d\u043e\u0432\u044b\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c: ' + message ) broadcast ( message + ', \u0434\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u0447\u0430\u0442!' , connection ) else : message_to_send = name + ': ' + message broadcast ( message_to_send , connection ) else : if user in list_of_users : list_of_users . remove ( user ) except : continue def broadcast ( message , connection ): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c \u0447\u0430\u0442\u0430, \u043a\u0440\u043e\u043c\u0435 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0433\u043e for user in list_of_users : user_conn = user [ 0 ] if user_conn != connection : try : user_conn . send ( message . encode ( 'utf-8' )) except : if user in list_of_users : list_of_users . remove ( user ) while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u043d\u043e\u0432\u044b\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u0435 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a conn , addr = sock . accept () list_of_users . append ([ conn , '' ]) print ( addr [ 0 ] + \" connected\" ) start_new_thread ( client_thread , ( list_of_users [ len ( list_of_users ) - 1 ],)) sock . close () client.py import socket import _thread LOCAL_PORT = 25030 BUFFER_SIZE = 1024 def handle_messages ( connection ): while True : msg = connection . recv ( 1024 ) if not msg : connection . close () break print ( msg . decode ( 'utf-8' )) sock = socket . socket () print ( '\u041f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u044c\u0442\u0435\u0441\u044c, \u043f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430:' ) name = input () # \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f sock . connect (( 'localhost' , LOCAL_PORT )) print ( '\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e.' ) _thread . start_new_thread ( handle_messages , ( sock ,)) # \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0442\u043e\u043a\u0435 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u043c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0432 # \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 sock . send ( name . encode ( 'utf-8' )) while True : message = input () # \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0432 \u0447\u0430\u0442 \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 if message == 'exit' : # \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \"exit\" break sock . send ( message . encode ( 'utf-8' )) sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21165 server.py import json import socket import sys from email.parser import Parser from functools import lru_cache from urllib.parse import parse_qs , urlparse MAX_LINE = 64 * 1024 MAX_HEADERS = 100 class MyHTTPServer : # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u0435\u0440\u0432\u0435\u0440\u0430 def __init__ ( self , host , port , server_name ): self . _host = host self . _port = port self . _server_name = server_name self . _disciplines = {} def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) try : serv_sock . bind (( self . _host , self . _port )) serv_sock . listen () while True : conn , _ = serv_sock . accept () try : self . serve_client ( conn ) except Exception as e : print ( 'Client serving failed' , e ) finally : serv_sock . close () def serve_client ( self , conn ): try : req = self . parse_request ( conn ) resp = self . handle_request ( req ) self . send_response ( conn , resp ) except ConnectionResetError : conn = None except Exception as e : print ( e ) self . send_error ( conn , e ) if conn : conn . close () def parse_request ( self , conn ): rfile = conn . makefile ( 'rb' ) method , target , ver = self . parse_request_line ( rfile ) headers = self . parse_headers ( rfile ) host = headers . get ( 'Host' ) if not host : raise HTTPError ( 400 , 'Bad request' , 'Host header is missing' ) if host not in ( self . _server_name , f ' { self . _server_name } : { self . _port } ' ): raise HTTPError ( 404 , 'Not found' ) return Request ( method , target , ver , headers , rfile ) def parse_request_line ( self , rfile ): raw = rfile . readline ( MAX_LINE + 1 ) if len ( raw ) > MAX_LINE : raise HTTPError ( 400 , 'Bad request' , 'Request line is too long' ) req_line = str ( raw , 'iso-8859-1' ) words = req_line . split () if len ( words ) != 3 : raise HTTPError ( 400 , 'Bad request' , 'Malformed request line' ) method , target , ver = words if ver != 'HTTP/1.1' : raise HTTPError ( 505 , 'HTTP Version Not Supported' ) return method , target , ver def parse_headers ( self , rfile ): headers = [] while True : line = rfile . readline ( MAX_LINE + 1 ) if len ( line ) > MAX_LINE : raise HTTPError ( 494 , 'Request header too large' ) if line in ( b ' \\r\\n ' , b ' \\n ' , b '' ): break headers . append ( line ) if len ( headers ) > MAX_HEADERS : raise HTTPError ( 494 , 'Too many headers' ) sheaders = b '' . join ( headers ) . decode ( 'iso-8859-1' ) return Parser () . parsestr ( sheaders ) def handle_request ( self , req ): if req . path == '/disciplines' and req . method == 'POST' : return self . handle_post_disciplines ( req ) if req . path == '/disciplines' and req . method == 'GET' : return self . handle_get_disciplines ( req ) raise Exception ( 'Not found' ) def send_response ( self , conn , resp ): wfile = conn . makefile ( 'wb' ) status_line = f 'HTTP/1.1 { resp . status } { resp . reason } \\r\\n ' wfile . write ( status_line . encode ( 'iso-8859-1' )) if resp . headers : for ( key , value ) in resp . headers : header_line = f ' { key } : { value } \\r\\n ' wfile . write ( header_line . encode ( 'iso-8859-1' )) wfile . write ( b ' \\r\\n ' ) if resp . body : wfile . write ( resp . body ) wfile . flush () wfile . close () def send_error ( self , conn , err ): try : status = err . status reason = err . reason body = ( err . body or err . reason ) . encode ( 'utf-8' ) except : status = 500 reason = b 'Internal Server Error' body = b 'Internal Server Error' resp = Response ( status , reason , [( 'Content-Length' , len ( body ))], body ) self . send_response ( conn , resp ) def handle_post_disciplines ( self , req ): discipline_id = len ( self . _disciplines ) + 1 self . _disciplines [ discipline_id ] = { 'id' : discipline_id , 'name' : req . query [ 'name' ][ 0 ], 'grade' : req . query [ 'grade' ][ 0 ]} return Response ( 204 , 'Created' ) def handle_get_disciplines ( self , req ): accept = req . headers . get ( 'Accept' ) if 'text/html' in accept : contentType = 'text/html; charset=utf-8' body = '<html><head></head><body>' body += f '<div>\u0414\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b ( { len ( self . _disciplines ) } )</div>' body += '<ul>' for u in self . _disciplines . values (): body += f '<li># { u [ \"id\" ] } { u [ \"name\" ] } , { u [ \"grade\" ] } </li>' body += '</ul>' body += '</body></html>' elif 'application/json' in accept : contentType = 'application/json; charset=utf-8' body = json . dumps ( self . _disciplines ) else : return Response ( 406 , 'Not Acceptable' ) body = body . encode ( 'utf-8' ) headers = [( 'Content-Type' , contentType ), ( 'Content-Length' , len ( body ))] return Response ( 200 , 'OK' , headers , body ) class Request : def body ( self ): size = self . headers . get ( 'Content-Length' ) if not size : return None return self . rfile . read ( size ) def __init__ ( self , method , target , version , headers , rfile ): self . method = method self . target = target self . version = version self . headers = headers self . rfile = rfile @property def path ( self ): return self . url . path @property @lru_cache ( None ) def query ( self ): return parse_qs ( self . url . query ) @property @lru_cache ( None ) def url ( self ): return urlparse ( self . target ) class Response : def __init__ ( self , status , reason , headers = None , body = None ): self . status = status self . reason = reason self . headers = headers self . body = body class HTTPError ( Exception ): def __init__ ( self , status , reason , body = None ): super () self . status = status self . reason = reason self . body = body if __name__ == '__main__' : host = sys . argv [ 1 ] port = int ( sys . argv [ 2 ]) name = sys . argv [ 3 ] serv = MyHTTPServer ( host , port , name ) try : serv . serve_forever () except KeyboardInterrupt : pass","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lab1/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lab1/#no1_1","text":"server.py import socket HELLO_MESSAGE = 'Hello, client' LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 UDP \u0441\u043e\u043a\u0435\u0442\u0430 sock . bind (( '' , LOCAL_PORT )) # \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0430 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u043f\u043e\u0440\u0442\u0443 while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 data , address = sock . recvfrom ( BUFFER_SIZE ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0430\u0434\u0440\u0435\u0441 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 print ( data . decode ( \"utf-8\" )) # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 sock . sendto ( HELLO_MESSAGE . encode ( \"utf-8\" ), address ) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0442\u0432\u0435\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 client.py import socket HELLO_MESSAGE = 'Hello, server' LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 UDP \u0441\u043e\u043a\u0435\u0442\u0430 sock . sendto ( HELLO_MESSAGE . encode ( \"utf-8\" ), ( \"localhost\" , LOCAL_PORT )) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 data = sock . recv ( BUFFER_SIZE ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 print ( data . decode ( \"utf-8\" )) # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043e\u0442\u0432\u0435\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21161"},{"location":"lab1/#no2","text":"server.py import socket from math import sqrt LOCAL_PORT = 25030 MAX_CLIENTS = 1 BUFFER_SIZE = 1024 sock = socket . socket () # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 TCP \u0441\u043e\u043a\u0435\u0442\u0430 sock . bind (( '' , LOCAL_PORT )) # \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0430 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u043f\u043e\u0440\u0442\u0443 sock . listen ( MAX_CLIENTS ) # \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u0445 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 conn , addr = sock . accept () # \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 1 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 print ( '\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e.' ) step = 1 with_hypo_input = False side_a = 0 side_b = 0 def solve_pyth ( a , b , with_hypo ): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u043f\u043e \u0442\u0435\u043e\u0440\u0435\u043c\u0435 \u041f\u0438\u0444\u0430\u0433\u043e\u0440\u0430 high = a if a > b else b low = a if a < b else b return sqrt ( high * high + low * low * ( - 1 if with_hypo else 1 )) while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 data = conn . recv ( 1024 ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 if not data : break message = data . decode ( 'utf-8' ) if message == '\u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044c' : # \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u043e \u043a\u043e\u043c\u0430\u043d\u0434\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 break if step == 1 : # \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0448\u0430\u0433\u0430 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u0430, \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0434\u0430\u043d\u043d\u044b\u0435 conn . send ( '\u0412\u044b \u0441\u043e\u0431\u0438\u0440\u0430\u0435\u0442\u0435\u0441\u044c \u0432\u0432\u043e\u0434\u0438\u0442\u044c \u0433\u0438\u043f\u043e\u0442\u0435\u043d\u0443\u0437\u0443? (\u0434\u0430/\u043d\u0435\u0442)' . encode ( 'utf-8' )) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0432\u043e\u043f\u0440\u043e\u0441 \u043f\u0440\u043e \u0433\u0438\u043f\u043e\u0442\u0435\u043d\u0443\u0437\u0443.' ) step += 1 elif step == 2 : if message . lower () == '\u0434\u0430' : with_hypo_input = True print ( '\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0442\u0432\u0435\u0442: ' + message ) conn . send ( '\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0435\u0440\u0432\u0443\u044e \u0441\u0442\u043e\u0440\u043e\u043d\u0443.' . encode ( 'utf-8' )) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0437\u0430\u043f\u0440\u043e\u0441 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b.' ) step += 1 elif step == 3 : side_a = float ( message ) print ( '\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0442\u0432\u0435\u0442: ' + message ) conn . send ( '\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0442\u043e\u0440\u0443\u044e \u0441\u0442\u043e\u0440\u043e\u043d\u0443.' . encode ( 'utf-8' )) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0437\u0430\u043f\u0440\u043e\u0441 \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b.' ) step += 1 elif step == 4 : print ( '\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0442\u0432\u0435\u0442: ' + message ) side_b = float ( message ) side_c = solve_pyth ( side_a , side_b , with_hypo_input ) print ( '\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0440\u0435\u0448\u0435\u043d\u0438\u0435: ' + str ( side_c )) conn . send (( '\u0422\u0440\u0435\u0442\u044c\u044f \u0441\u0442\u043e\u0440\u043e\u043d\u0430: ' + str ( side_c )) . encode ( 'utf-8' )) step = 1 conn . close () client.py import socket LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket () # \u0441\u043e\u0437\u0434\u0430\u0435\u043c TCP \u0441\u043e\u043a\u0435\u0442 sock . connect (( 'localhost' , LOCAL_PORT )) # \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u0441\u044f \u043a \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 message = input () # \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0432\u0432\u043e\u0434 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f if message . lower () == 'exit' : # \u0435\u0441\u043b\u0438 \u0432\u0432\u0435\u0434\u0435\u043d\u043e \"exit\", \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 break sock . send ( message . encode ( 'utf-8' )) # \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 data = sock . recv ( BUFFER_SIZE ) # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 print ( data . decode ( 'utf-8' )) # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043e\u0442\u0432\u0435\u0442 sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21162"},{"location":"lab1/#no3","text":"server.py import socket from wsgiref.handlers import format_date_time from datetime import datetime from time import mktime LOCAL_PORT = 25030 MAX_CLIENTS = 10 BUFFER_SIZE = 1024 SERVER_NAME = 'chiclasserver/1.0.0' sock = socket . socket () sock . bind (( '' , LOCAL_PORT )) sock . listen ( MAX_CLIENTS ) with open ( 'index.html' , 'r' ) as file : # \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 file_data = file . read () now = datetime . now () # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u0432 \u043d\u0443\u0436\u043d\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0434\u043b\u044f \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0432 \u043f\u043e\u043b\u0435 \u0434\u0430\u0442\u044b stamp = mktime ( now . timetuple ()) date = format_date_time ( stamp ) dt = datetime . strptime ( '24/09/22 15:08' , ' %d /%m/%y %H:%M' ) # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u0432 \u043d\u0443\u0436\u043d\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0434\u043b\u044f \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0432 \u043f\u043e\u043b\u0435 # \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 stamp = mktime ( dt . timetuple ()) last_modified = format_date_time ( stamp ) content_length = len ( file_data . encode ( 'utf-8' )) # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430 data = f '''HTTP/1.1 200 OK Server: { SERVER_NAME } Date: { date } Content-Type: text/html Content-Length: { content_length } Last-Modified: { last_modified } Connection: keep-alive Access-Control-Allow-Origin: * Accept-Ranges: bytes ''' data += file_data while True : conn , addr = sock . accept () conn . send ( data . encode ( 'utf-8' )) print ( 'index.html \u0431\u044b\u043b \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d' ) conn . close () client.py import socket LOCAL_PORT = 25030 BUFFER_SIZE = 1024 sock = socket . socket () sock . connect (( 'localhost' , LOCAL_PORT )) data = sock . recv ( BUFFER_SIZE ) print ( data . decode ( 'utf-8' )) sock . close () index.html <!DOCTYPE html> < html > < head > < title > Web programming lab 1 </ title > </ head > < body > < h1 > Hello world </ h1 > </ body > </ html >","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163"},{"location":"lab1/#no4","text":"server.py import socket from _thread import * LOCAL_PORT = 25030 MAX_CLIENTS = 10 BUFFER_SIZE = 1024 sock = socket . socket () sock . bind (( '' , LOCAL_PORT )) sock . listen ( MAX_CLIENTS ) list_of_users = [] # \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 def client_thread ( user ): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f connection = user [ 0 ] connection . send ( '\u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u0447\u0430\u0442!' . encode ( 'utf-8' )) while True : try : name = user [ 1 ] data = connection . recv ( 1024 ) if data : message = data . decode ( 'utf-8' ) if name == '' : # \u0435\u0441\u043b\u0438 \u0438\u043c\u044f \u043d\u0435 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u043e, \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u043c\u0432\u0430\u0435\u043c user [ 1 ] = message print ( '\u041d\u043e\u0432\u044b\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c: ' + message ) broadcast ( message + ', \u0434\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u0447\u0430\u0442!' , connection ) else : message_to_send = name + ': ' + message broadcast ( message_to_send , connection ) else : if user in list_of_users : list_of_users . remove ( user ) except : continue def broadcast ( message , connection ): # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c \u0447\u0430\u0442\u0430, \u043a\u0440\u043e\u043c\u0435 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0433\u043e for user in list_of_users : user_conn = user [ 0 ] if user_conn != connection : try : user_conn . send ( message . encode ( 'utf-8' )) except : if user in list_of_users : list_of_users . remove ( user ) while True : # \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u043d\u043e\u0432\u044b\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u0435 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a conn , addr = sock . accept () list_of_users . append ([ conn , '' ]) print ( addr [ 0 ] + \" connected\" ) start_new_thread ( client_thread , ( list_of_users [ len ( list_of_users ) - 1 ],)) sock . close () client.py import socket import _thread LOCAL_PORT = 25030 BUFFER_SIZE = 1024 def handle_messages ( connection ): while True : msg = connection . recv ( 1024 ) if not msg : connection . close () break print ( msg . decode ( 'utf-8' )) sock = socket . socket () print ( '\u041f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u044c\u0442\u0435\u0441\u044c, \u043f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430:' ) name = input () # \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f sock . connect (( 'localhost' , LOCAL_PORT )) print ( '\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e.' ) _thread . start_new_thread ( handle_messages , ( sock ,)) # \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0442\u043e\u043a\u0435 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u043c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0432 # \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 sock . send ( name . encode ( 'utf-8' )) while True : message = input () # \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0432 \u0447\u0430\u0442 \u0432 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435 if message == 'exit' : # \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \"exit\" break sock . send ( message . encode ( 'utf-8' )) sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21164"},{"location":"lab1/#no5","text":"server.py import json import socket import sys from email.parser import Parser from functools import lru_cache from urllib.parse import parse_qs , urlparse MAX_LINE = 64 * 1024 MAX_HEADERS = 100 class MyHTTPServer : # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u0435\u0440\u0432\u0435\u0440\u0430 def __init__ ( self , host , port , server_name ): self . _host = host self . _port = port self . _server_name = server_name self . _disciplines = {} def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) try : serv_sock . bind (( self . _host , self . _port )) serv_sock . listen () while True : conn , _ = serv_sock . accept () try : self . serve_client ( conn ) except Exception as e : print ( 'Client serving failed' , e ) finally : serv_sock . close () def serve_client ( self , conn ): try : req = self . parse_request ( conn ) resp = self . handle_request ( req ) self . send_response ( conn , resp ) except ConnectionResetError : conn = None except Exception as e : print ( e ) self . send_error ( conn , e ) if conn : conn . close () def parse_request ( self , conn ): rfile = conn . makefile ( 'rb' ) method , target , ver = self . parse_request_line ( rfile ) headers = self . parse_headers ( rfile ) host = headers . get ( 'Host' ) if not host : raise HTTPError ( 400 , 'Bad request' , 'Host header is missing' ) if host not in ( self . _server_name , f ' { self . _server_name } : { self . _port } ' ): raise HTTPError ( 404 , 'Not found' ) return Request ( method , target , ver , headers , rfile ) def parse_request_line ( self , rfile ): raw = rfile . readline ( MAX_LINE + 1 ) if len ( raw ) > MAX_LINE : raise HTTPError ( 400 , 'Bad request' , 'Request line is too long' ) req_line = str ( raw , 'iso-8859-1' ) words = req_line . split () if len ( words ) != 3 : raise HTTPError ( 400 , 'Bad request' , 'Malformed request line' ) method , target , ver = words if ver != 'HTTP/1.1' : raise HTTPError ( 505 , 'HTTP Version Not Supported' ) return method , target , ver def parse_headers ( self , rfile ): headers = [] while True : line = rfile . readline ( MAX_LINE + 1 ) if len ( line ) > MAX_LINE : raise HTTPError ( 494 , 'Request header too large' ) if line in ( b ' \\r\\n ' , b ' \\n ' , b '' ): break headers . append ( line ) if len ( headers ) > MAX_HEADERS : raise HTTPError ( 494 , 'Too many headers' ) sheaders = b '' . join ( headers ) . decode ( 'iso-8859-1' ) return Parser () . parsestr ( sheaders ) def handle_request ( self , req ): if req . path == '/disciplines' and req . method == 'POST' : return self . handle_post_disciplines ( req ) if req . path == '/disciplines' and req . method == 'GET' : return self . handle_get_disciplines ( req ) raise Exception ( 'Not found' ) def send_response ( self , conn , resp ): wfile = conn . makefile ( 'wb' ) status_line = f 'HTTP/1.1 { resp . status } { resp . reason } \\r\\n ' wfile . write ( status_line . encode ( 'iso-8859-1' )) if resp . headers : for ( key , value ) in resp . headers : header_line = f ' { key } : { value } \\r\\n ' wfile . write ( header_line . encode ( 'iso-8859-1' )) wfile . write ( b ' \\r\\n ' ) if resp . body : wfile . write ( resp . body ) wfile . flush () wfile . close () def send_error ( self , conn , err ): try : status = err . status reason = err . reason body = ( err . body or err . reason ) . encode ( 'utf-8' ) except : status = 500 reason = b 'Internal Server Error' body = b 'Internal Server Error' resp = Response ( status , reason , [( 'Content-Length' , len ( body ))], body ) self . send_response ( conn , resp ) def handle_post_disciplines ( self , req ): discipline_id = len ( self . _disciplines ) + 1 self . _disciplines [ discipline_id ] = { 'id' : discipline_id , 'name' : req . query [ 'name' ][ 0 ], 'grade' : req . query [ 'grade' ][ 0 ]} return Response ( 204 , 'Created' ) def handle_get_disciplines ( self , req ): accept = req . headers . get ( 'Accept' ) if 'text/html' in accept : contentType = 'text/html; charset=utf-8' body = '<html><head></head><body>' body += f '<div>\u0414\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b ( { len ( self . _disciplines ) } )</div>' body += '<ul>' for u in self . _disciplines . values (): body += f '<li># { u [ \"id\" ] } { u [ \"name\" ] } , { u [ \"grade\" ] } </li>' body += '</ul>' body += '</body></html>' elif 'application/json' in accept : contentType = 'application/json; charset=utf-8' body = json . dumps ( self . _disciplines ) else : return Response ( 406 , 'Not Acceptable' ) body = body . encode ( 'utf-8' ) headers = [( 'Content-Type' , contentType ), ( 'Content-Length' , len ( body ))] return Response ( 200 , 'OK' , headers , body ) class Request : def body ( self ): size = self . headers . get ( 'Content-Length' ) if not size : return None return self . rfile . read ( size ) def __init__ ( self , method , target , version , headers , rfile ): self . method = method self . target = target self . version = version self . headers = headers self . rfile = rfile @property def path ( self ): return self . url . path @property @lru_cache ( None ) def query ( self ): return parse_qs ( self . url . query ) @property @lru_cache ( None ) def url ( self ): return urlparse ( self . target ) class Response : def __init__ ( self , status , reason , headers = None , body = None ): self . status = status self . reason = reason self . headers = headers self . body = body class HTTPError ( Exception ): def __init__ ( self , status , reason , body = None ): super () self . status = status self . reason = reason self . body = body if __name__ == '__main__' : host = sys . argv [ 1 ] port = int ( sys . argv [ 2 ]) name = sys . argv [ 3 ] serv = MyHTTPServer ( host , port , name ) try : serv . serve_forever () except KeyboardInterrupt : pass","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21165"}]}